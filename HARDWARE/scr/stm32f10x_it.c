

#include "stm32f10x.h"     //包含需要的头文件
#include "stm32f10x_it.h"  //包含需要的头文件
#include "main.h"          //包含需要的头文件
#include "delay.h"         //包含需要的头文件
#include "usart1.h"        //包含需要的头文件
#include "timer1.h"        //包含需要的头文件
#include "led.h"           //包含需要的头文件
#include "global.h"


/*-------------------------------------------------*/
/*函数名：串口2接收中断函数                        */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/

/*-------------------------------------------------*/
/*函数名：定时器2中断服务函数                      */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void TIM2_IRQHandler(void)
{	
	if(TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET){  //如果TIM_IT_Update置位，表示TIM2溢出中断，进入if	
		
		timecount1++;
		timecount2++;
		timecount3++;
		timecount4++;
		timecount5++;
		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);     //清除TIM2溢出中断标志 	
	}
}
/*-------------------------------------------------*/
/*函数名：不可屏蔽中断处理函数                     */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void NMI_Handler(void)
{

}

/*-------------------------------------------------*/
/*函数名：硬件出错后进入的中断处理函数             */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void HardFault_Handler(void)
{

}

/*-------------------------------------------------*/
/*函数名：内存管理中断处理函数                     */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void MemManage_Handler(void)
{

}

/*-------------------------------------------------*/
/*函数名：预取指失败，存储器访问失败中断处理函数   */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void BusFault_Handler(void)
{

}

/*-------------------------------------------------*/
/*函数名：未定义的指令或非法状态处理函数           */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void UsageFault_Handler(void)
{

}

/*-------------------------------------------------*/
/*函数名：软中断，SWI 指令调用的处理函数           */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void SVC_Handler(void)
{
	
}

/*-------------------------------------------------*/
/*函数名：调试监控器处理函数                       */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void DebugMon_Handler(void)
{
	
}

/*-------------------------------------------------*/
/*函数名：可挂起的系统服务处理函数                 */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void PendSV_Handler(void)
{
}

/*-------------------------------------------------*/
/*函数名：SysTic系统嘀嗒定时器处理函数             */
/*参  数：无                                       */
/*返回值：无                                       */
/*-------------------------------------------------*/
void SysTick_Handler(void)
{
 
}

/*-------------------------------------------------*/
/*函数名：串口1中断服务函数 (健壮版本)             */
/*-------------------------------------------------*/
void USART1_IRQHandler(void)
{
    uint8_t received_char;

    if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
    {
        // 1. 读取数据寄存器，这个操作会自动清除中断标志位
        received_char = USART_ReceiveData(USART1);
        
        // 2. 检查缓冲区是否还有空间 (至少要留一个位置给 '\0')
        if(usart1_rx_len < (USART1_RXBUFF_SIZE - 1))
        {
            usart1_rx_buffer[usart1_rx_len] = received_char;
            usart1_rx_len++;
            
            // 3. 关键步骤：在每次接收后，都在数据末尾补上'\0'，确保它始终是有效的字符串
            usart1_rx_buffer[usart1_rx_len] = '\0';
        }
        else
        {
            // 缓冲区满了，可以选择清空或丢弃，这里我们保持清空策略以接收最新数据
            usart1_rx_len = 0;
            usart1_rx_buffer[0] = '\0';
        }
    }
}
